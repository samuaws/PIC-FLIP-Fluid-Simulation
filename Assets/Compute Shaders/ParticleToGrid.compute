#pragma kernel TransferParticlesToGrid

int gridResolution;
float cellSize;

struct Particle
{
    float3 position;
    float3 velocity;
};

StructuredBuffer<Particle> particles;
RWStructuredBuffer<float3> velocityBuffer;
RWStructuredBuffer<float> massBuffer;

// Tricubic kernel function must be defined before it's used in the kernel
float TricubicKernel(float x)
{
    x = abs(x);
    if (x < 1.0)
    {
        return 1.5 * pow(x, 3) - 2.5 * pow(x, 2) + 1.0;
    }
    else if (x < 2.0)
    {
        return -0.5 * pow(x - 2.0, 3) + 2.5 * pow(x - 2.0, 2) - 4.0 * (x - 2.0) + 2.0;
    }
    else
    {
        return 0.0;
    }
}

[numthreads(64, 1, 1)]
void TransferParticlesToGrid(uint id : SV_DispatchThreadID)
{
    Particle p = particles[id];
    
    int xIndex = floor(p.position.x / cellSize);
    int yIndex = floor(p.position.y / cellSize);
    int zIndex = floor(p.position.z / cellSize);

    float3 gridPosition = float3(xIndex, yIndex, zIndex) * cellSize;
    float3 offset = (p.position - gridPosition) / cellSize;

    for (int i = -1; i <= 2; i++)
    {
        for (int j = -1; j <= 2; j++)
        {
            for (int k = -1; k <= 2; k++)
            {
                int gridX = xIndex + i;
                int gridY = yIndex + j;
                int gridZ = zIndex + k;

                if (gridX >= 0 && gridX < gridResolution &&
                    gridY >= 0 && gridY < gridResolution &&
                    gridZ >= 0 && gridZ < gridResolution)
                {
                    int gridIndex = gridX + gridY * gridResolution + gridZ * gridResolution * gridResolution;

                    float weight = TricubicKernel(offset.x - i) *
                                   TricubicKernel(offset.y - j) *
                                   TricubicKernel(offset.z - k);

                    // Accumulate contributions locally
                    float localMass = massBuffer[gridIndex];
                    float3 localVelocity = velocityBuffer[gridIndex];

                    localMass += weight;
                    localVelocity += p.velocity * weight;

                    // Write back to global memory
                    massBuffer[gridIndex] = localMass;
                    velocityBuffer[gridIndex] = localVelocity;
                }
            }
        }
    }
}
