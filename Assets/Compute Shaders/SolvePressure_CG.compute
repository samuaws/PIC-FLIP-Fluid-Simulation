#pragma kernel ConjugateGradientStep

int gridResolution;
float cellSize;
float timeStep;

RWStructuredBuffer<float> pressure;      // Pressure values
RWStructuredBuffer<float> divergence;    // Divergence of the velocity field
RWStructuredBuffer<float3> velocities;   // Grid velocities
RWStructuredBuffer<float> residual;      // Residual of the pressure solve
RWStructuredBuffer<float> direction;     // Direction vector for CG
RWStructuredBuffer<float> Ap;            // Matrix-vector multiplication result

// Define ComputeBeta function
float ComputeBeta(float residual, float direction)
{
    return (residual * residual) / (direction * direction);
}

// Define GetLaplacian function
float GetLaplacian(RWStructuredBuffer<float> field, uint3 id)
{
    return field[id.x + 1 + id.y * gridResolution + id.z * gridResolution * gridResolution] +
           field[id.x - 1 + id.y * gridResolution + id.z * gridResolution * gridResolution] +
           field[id.x + (id.y + 1) * gridResolution + id.z * gridResolution * gridResolution] +
           field[id.x + (id.y - 1) * gridResolution + id.z * gridResolution * gridResolution] +
           field[id.x + id.y * gridResolution + (id.z + 1) * gridResolution * gridResolution] +
           field[id.x + id.y * gridResolution + (id.z - 1) * gridResolution * gridResolution] -
           6.0f * field[id.x + id.y * gridResolution + id.z * gridResolution * gridResolution];
}

// Define GetGradient function
float3 GetGradient(RWStructuredBuffer<float> field, uint3 id)
{
    float3 gradient;
    gradient.x = field[id.x + 1 + id.y * gridResolution + id.z * gridResolution * gridResolution] -
                 field[id.x - 1 + id.y * gridResolution + id.z * gridResolution * gridResolution];
    gradient.y = field[id.x + (id.y + 1) * gridResolution + id.z * gridResolution * gridResolution] -
                 field[id.x + (id.y - 1) * gridResolution + id.z * gridResolution * gridResolution];
    gradient.z = field[id.x + id.y * gridResolution + (id.z + 1) * gridResolution * gridResolution] -
                 field[id.x + id.y * gridResolution + (id.z - 1) * gridResolution * gridResolution];

    return gradient / (2.0f * cellSize);
}

[numthreads(8, 8, 8)]
void ConjugateGradientStep(uint3 id : SV_DispatchThreadID)
{
    int index = id.x + id.y * gridResolution + id.z * gridResolution * gridResolution;

    // Compute Ap (A * p)
    float laplacian = GetLaplacian(pressure, id);
    Ap[index] = laplacian;

    // Update residual
    residual[index] = divergence[index] - laplacian;

    // Update direction
    direction[index] = residual[index] + ComputeBeta(residual[index], direction[index]) * direction[index];

    // Update pressure
    pressure[index] += direction[index] * timeStep;

    // Subtract pressure gradient from velocities
    float3 gradient = GetGradient(pressure, id);
    velocities[index] -= gradient / timeStep;
}
